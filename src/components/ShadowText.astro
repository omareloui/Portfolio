---
export interface Props {
  size?: string;
  translate?: string;
  ariaHidden?: boolean;
  parentQuery?: string;
  movingFraction?: number;
}

const {
  size = "clamp(3rem, 10vw, 5rem)",
  translate = "-30% -80%",
  ariaHidden = true,
  parentQuery,
  movingFraction = 2,
} = Astro.props;
---

<span
  class="shadow-text"
  aria-hidden={ariaHidden}
  data-parent={parentQuery}
  data-initial-translate={translate}
  data-moving-fraction={movingFraction}
>
  <slot />
</span>

<script>
  // eslint-disable-next-line
  const shadowElments: NodeListOf<HTMLElement> =
    document.querySelectorAll(".shadow-text");

  shadowElments.forEach(shadowEl => {
    let parent: Element | null;
    const parentQuery = shadowEl.dataset.parent;

    if (!parentQuery) parent = shadowEl.parentElement;
    else if (parentQuery === "prev") parent = shadowEl.previousElementSibling;
    else if (parentQuery === "next") parent = shadowEl.nextElementSibling;
    else parent = shadowEl.querySelector(parentQuery);

    if (!parent || !(parent instanceof HTMLElement)) return;

    function setParentStyles() {
      // eslint-disable-next-line
      // @ts-ignore
      parent.style.display = "relative";
    }

    function parseXYProps(value: string): [string, string] {
      const sanatized = value.trim().replace(/\s+/, " ").split(" ");
      if (sanatized.length > 2) throw new Error("Invalid translate value.");
      if (sanatized.length === 2) return sanatized as [string, string];
      return [sanatized[0], sanatized[0]] as [string, string];
    }

    function onEnterParent() {
      shadowEl.classList.add("shadow-text--on-parent");
    }

    function onMoveOverParent(e: PointerEvent) {
      const parent = e.target as HTMLElement;
      const boundingBox = parent.getBoundingClientRect();
      const movingFraction =
        parseInt(shadowEl.dataset.movingFraction || "", 10) || 2;

      const layerPos = {
        x: e.clientX - boundingBox.x,
        y: e.clientY - boundingBox.y,
      };

      const layerPosFromCenter = {
        x: layerPos.x - boundingBox.width / 2,
        y: layerPos.y - boundingBox.height / 2,
      };

      const xPerc = Math.round(
        (layerPosFromCenter.x / boundingBox.width) * 100
      );
      const yPerc = Math.round(
        (layerPosFromCenter.y / boundingBox.height) * 100
      );

      const [initialX, initialY] = parseXYProps(
        shadowEl.dataset.initialTranslate as string
      );

      shadowEl.style.setProperty(
        "--translate",
        `calc(${initialX} + ${xPerc / movingFraction}%) calc(${initialY} + ${
          yPerc / movingFraction
        }%`
      );
    }

    function onLeaveParent() {
      const initialTranslate = shadowEl.dataset.initialTranslate as string;
      shadowEl.style.setProperty("--translate", initialTranslate);
      shadowEl.classList.remove("shadow-text--on-parent");
    }

    parent.addEventListener("pointerenter", onEnterParent);
    parent.addEventListener("pointermove", onMoveOverParent);
    parent.addEventListener("pointerleave", onLeaveParent);
    setParentStyles();
  });
</script>

<style lang="scss" define:vars={{ size, translate }} is:global>
  @use "../assets/styles/mixins.scss" as *;

  .shadow-text {
    position: absolute;

    transition: ease-out 200ms;
    translate: var(--translate);

    color: var(--shadow-text);
    pointer-events: none;
    font-family: "Playfair Display", sans-serif;
    font-weight: bold;
    font-style: italic;
    font-size: var(--size);

    &--on-parent {
      scale: 1.2;
    }
  }
</style>
